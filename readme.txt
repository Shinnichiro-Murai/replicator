fsa.list:
行動の見間違えのある戦略を列挙．

fsaimpl.list:
行動の取り違えのある戦略を列挙．

fsa_impl_misp.list:
行動の見間違えと取り違えの対応付け．
左端の数字が，行動の見間違えの戦略(fsa.list)の番号と対応している．

fsa_impl_misp_sorted.list:
fsa_impl_misp.listを左端の数字について並び替えたもの．

fsa_impl_misp.memo:
fsa_impl_misp.pyの内容を説明．

-対応付けの方法-
行動の取り違えがある場合の戦略は
((状態0,状態1),((状態0のときの遷移),(状態1のときの遷移)))の形で表現される．
例えば，((C,D),((0,1,1,1),(0,1,1,0)))
状態0は初期状態を表し，Cの場合は状態R(reward．報酬)，
Dの場合は状態P(punishment，処罰)を表している．

自分は相手が選択した行動のシグナルを観測する．
相手がCを選択したときはg，Dを選択したときはbのシグナルを得る．
自分が選択した行動と観測したシグナルの組み合わせとして
Cg，Cb，Dg，Dbの4つが考えられる．
状態R,PいずれにしてもCg，Cb，Dg，Dbの
4つの行動が考えられる．

行動の取り違えがないときは
状態RではCgかCb，状態PではDgかDbのみ考えれば良いため，
シグナルによって状態が遷移する戦略と等しくなる．
そのため，上記の戦略は((C,D),((0,1),(1,0)))と表せる．
これを見間違えのある戦略のどれと同相であるかを関数isEq2で判定することで対応付けを行う．

関数isEq2は，深さ優先探索で積FSAの行動をチェックする関数で，
初期状態からシグナル列を伸ばしつつ行動をチェックするが，
一度チェックした積状態に到達したらそれ以降はチェック不要．
同一の遷移となっていた場合は，true，異なる状態に達したらfalseが返される．

例えば，次の2つのオートマトンが同じであるかどうかを判断する．
-((C,D),((0,1,1,1),(0,1,1,0)))・・・A
-((C,D),((0,1),(1,1)))　　　　 ・・・B
行動の取り違えがないため，オートマトンAは
-((C,D),((0,1),(1,0)))        ・・・A'
と表すことができる．

同じシグナル列をみたときにそれぞれのオートマトンでどの状態になるかを，状態のペアで表すとする．
初期状態は(0,0)．
gを観測したとき，状態は(0,0)．
最初にgを観測したときは初期状態に戻ることがわかるので，bから始まるシグナル列のみを考えればよい．
bを観測したとき，状態は(1,1)．
bgを観測したとき，状態は(1,1)．
bbを観測したとき，状態は(1,0)  ←状態が異なるため，2つは対応しない戦略であるとわかる．



(見間違え戦略の番号):(対応している取り違え戦略の個数)
1:49戦略(ALLC)
2:16戦略(FGV)
3:16戦略(TFT)
4:16戦略(WSLS)
5:16戦略(GRIM)
6:16戦略
7:16戦略
8:16戦略
9:16戦略
10:16戦略
11:16戦略
12:16戦略
13:16戦略
14:49戦略(ALLD)
15:16戦略
16:16戦略
17:16戦略
18:16戦略
19:16戦略
20:16戦略
21:16戦略
22:16戦略
23:16戦略
24:16戦略
25:16戦略
26:16戦略